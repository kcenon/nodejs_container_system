/**
 * @file cross_language.test.ts
 * @brief Cross-language binary compatibility tests
 *
 * These tests verify that Node.js can correctly serialize and deserialize
 * data that is compatible with C++, Python, .NET, Go, and Rust implementations.
 *
 * The tests use binary files generated by generate_test_data.ts to ensure
 * the wire format matches across all language implementations.
 */

import * as fs from 'fs';
import * as path from 'path';
import {
  ValueType,
  BoolValue,
  IntValue,
  LongValue,
  ULongValue,
  LLongValue,
  DoubleValue,
  StringValue,
  Container,
} from '../src';

const TEST_DATA_DIR = path.join(__dirname, 'test_data');

describe('Cross-Language Binary Compatibility', () => {
  test('verifies test data directory exists', () => {
    expect(fs.existsSync(TEST_DATA_DIR)).toBe(true);
  });

  describe('Type ID Verification', () => {
    test('BoolValue has correct type ID (1)', () => {
      const val = new BoolValue('test', true);
      expect(val.getType()).toBe(ValueType.Bool);
      expect(val.getType()).toBe(1);
    });

    test('LongValue has correct type ID (6)', () => {
      const result = LongValue.create('test', 100);
      expect(result.ok).toBe(true);
      if (result.ok) {
        expect(result.value.getType()).toBe(ValueType.Long);
        expect(result.value.getType()).toBe(6);
      }
    });

    test('ULongValue has correct type ID (7)', () => {
      const result = ULongValue.create('test', 100);
      expect(result.ok).toBe(true);
      if (result.ok) {
        expect(result.value.getType()).toBe(ValueType.ULong);
        expect(result.value.getType()).toBe(7);
      }
    });

    test('LLongValue has correct type ID (8)', () => {
      const val = new LLongValue('test', 100n);
      expect(val.getType()).toBe(ValueType.LLong);
      expect(val.getType()).toBe(8);
    });

    test('StringValue has correct type ID (13)', () => {
      const val = new StringValue('test', 'hello');
      expect(val.getType()).toBe(ValueType.String);
      expect(val.getType()).toBe(13);
    });

    test('Container has correct type ID (14)', () => {
      const container = new Container('test');
      expect(container.getType()).toBe(ValueType.Container);
      expect(container.getType()).toBe(14);
    });
  });

  describe('Wire Format Verification', () => {
    test('BoolValue serialization format matches spec', () => {
      const val = new BoolValue('test', true);
      const buffer = val.serialize();

      // Format: [type:1][name_len:4 LE][name:UTF-8][value_size:4 LE][value:bytes]
      expect(buffer.readUInt8(0)).toBe(1); // Type ID for Bool

      const nameLen = buffer.readUInt32LE(1);
      expect(nameLen).toBe(4); // "test".length

      const name = buffer.toString('utf-8', 5, 5 + nameLen);
      expect(name).toBe('test');

      const valueSize = buffer.readUInt32LE(5 + nameLen);
      expect(valueSize).toBe(1); // bool is 1 byte

      const value = buffer.readUInt8(5 + nameLen + 4);
      expect(value).toBe(1); // true
    });

    test('LongValue serializes to exactly 4 bytes (32-bit policy)', () => {
      const result = LongValue.create('test', 2000000000);
      expect(result.ok).toBe(true);

      if (result.ok) {
        const buffer = result.value.serialize();

        // Type byte
        expect(buffer.readUInt8(0)).toBe(6);

        // Extract value size
        const nameLen = buffer.readUInt32LE(1);
        const valueSizeOffset = 1 + 4 + nameLen;
        const valueSize = buffer.readUInt32LE(valueSizeOffset);

        // CRITICAL: Long must be 4 bytes to match C++ 32-bit policy
        expect(valueSize).toBe(4);

        // Verify value can be read as int32
        const valueOffset = valueSizeOffset + 4;
        const value = buffer.readInt32LE(valueOffset);
        expect(value).toBe(2000000000);
      }
    });

    test('ULongValue serializes to exactly 4 bytes (32-bit policy)', () => {
      const result = ULongValue.create('test', 3500000000);
      expect(result.ok).toBe(true);

      if (result.ok) {
        const buffer = result.value.serialize();
        const nameLen = buffer.readUInt32LE(1);
        const valueSizeOffset = 1 + 4 + nameLen;
        const valueSize = buffer.readUInt32LE(valueSizeOffset);

        // CRITICAL: ULong must be 4 bytes to match C++ 32-bit policy
        expect(valueSize).toBe(4);
      }
    });

    test('LLongValue serializes to exactly 8 bytes (64-bit)', () => {
      const val = new LLongValue('test', 5000000000n);
      const buffer = val.serialize();
      const nameLen = buffer.readUInt32LE(1);
      const valueSizeOffset = 1 + 4 + nameLen;
      const valueSize = buffer.readUInt32LE(valueSizeOffset);

      expect(valueSize).toBe(8);
    });

    test('StringValue format with UTF-8 encoding', () => {
      const val = new StringValue('name', 'Hello');
      const buffer = val.serialize();

      expect(buffer.readUInt8(0)).toBe(13); // Type ID for String

      const nameLen = buffer.readUInt32LE(1);
      const name = buffer.toString('utf-8', 5, 5 + nameLen);
      expect(name).toBe('name');

      const valueSize = buffer.readUInt32LE(5 + nameLen);
      expect(valueSize).toBe(5); // "Hello".length

      const value = buffer.toString('utf-8', 5 + nameLen + 4, 5 + nameLen + 4 + valueSize);
      expect(value).toBe('Hello');
    });
  });

  describe('Round-trip Serialization', () => {
    test('BoolValue round-trip', () => {
      const original = new BoolValue('flag', true);
      const buffer = original.serialize();
      const { value } = Container.deserializeValue(buffer, 0);

      expect(value.getName()).toBe('flag');
      expect((value as BoolValue).getValue()).toBe(true);
    });

    test('LongValue round-trip (32-bit policy)', () => {
      const result1 = LongValue.create('count', 2000000000);
      expect(result1.ok).toBe(true);

      if (result1.ok) {
        const buffer = result1.value.serialize();
        const { value } = Container.deserializeValue(buffer, 0);

        expect(value.getName()).toBe('count');
        expect((value as LongValue).getValue()).toBe(2000000000);
      }
    });

    test('LLongValue round-trip (64-bit)', () => {
      const original = new LLongValue('big', 5000000000n);
      const buffer = original.serialize();
      const { value } = Container.deserializeValue(buffer, 0);

      expect(value.getName()).toBe('big');
      expect((value as LLongValue).getValue()).toBe(5000000000n);
    });

    test('StringValue round-trip with UTF-8', () => {
      const original = new StringValue('message', 'UTF-8: í•œê¸€ ðŸš€');
      const buffer = original.serialize();
      const { value } = Container.deserializeValue(buffer, 0);

      expect(value.getName()).toBe('message');
      expect((value as StringValue).getValue()).toBe('UTF-8: í•œê¸€ ðŸš€');
    });

    test('Container round-trip with multiple types', () => {
      const container = new Container('data');
      container.add(new BoolValue('flag', true));

      const intResult = IntValue.create('count', 42);
      if (intResult.ok) {
        container.add(intResult.value);
      }

      container.add(new StringValue('name', 'test'));

      const buffer = container.serialize();
      const result = Container.deserialize(buffer);

      expect(result.value.getName()).toBe('data');
      expect(result.value.size()).toBe(3);
      expect((result.value.get('flag') as BoolValue).getValue()).toBe(true);
      expect((result.value.get('count') as IntValue).getValue()).toBe(42);
      expect((result.value.get('name') as StringValue).getValue()).toBe('test');
    });
  });

  describe('Generated Test Data Files', () => {
    test('can read back nodejs_long.bin', () => {
      const filepath = path.join(TEST_DATA_DIR, 'nodejs_long.bin');
      expect(fs.existsSync(filepath)).toBe(true);

      const buffer = fs.readFileSync(filepath);
      const { value } = Container.deserializeValue(buffer, 0);

      expect(value.getName()).toBe('long_32bit');
      expect((value as LongValue).getValue()).toBe(2000000000);
    });

    test('can read back nodejs_string.bin', () => {
      const filepath = path.join(TEST_DATA_DIR, 'nodejs_string.bin');
      expect(fs.existsSync(filepath)).toBe(true);

      const buffer = fs.readFileSync(filepath);
      const { value } = Container.deserializeValue(buffer, 0);

      expect(value.getName()).toBe('string_hello');
      expect((value as StringValue).getValue()).toBe('Hello from Node.js!');
    });

    test('can read back nodejs_container.bin', () => {
      const filepath = path.join(TEST_DATA_DIR, 'nodejs_container.bin');
      expect(fs.existsSync(filepath)).toBe(true);

      const buffer = fs.readFileSync(filepath);
      const result = Container.deserialize(buffer);

      expect(result.value.getName()).toBe('test_container');
      expect(result.value.size()).toBe(3);
      expect(result.value.has('nested_int')).toBe(true);
      expect(result.value.has('nested_str')).toBe(true);
      expect(result.value.has('nested_long')).toBe(true);

      const intVal = result.value.get('nested_int') as IntValue;
      expect(intVal.getValue()).toBe(42);

      const strVal = result.value.get('nested_str') as StringValue;
      expect(strVal.getValue()).toBe('nested value');

      const longVal = result.value.get('nested_long') as LongValue;
      expect(longVal.getValue()).toBe(1234567890);
    });

    test('can read back nodejs_complex.bin', () => {
      const filepath = path.join(TEST_DATA_DIR, 'nodejs_complex.bin');
      expect(fs.existsSync(filepath)).toBe(true);

      const buffer = fs.readFileSync(filepath);
      const result = Container.deserialize(buffer);

      expect(result.value.size()).toBe(5);
      expect((result.value.get('flag') as BoolValue).getValue()).toBe(true);
      expect((result.value.get('count') as IntValue).getValue()).toBe(100);
      expect((result.value.get('timestamp') as LongValue).getValue()).toBe(1234567890);
      expect((result.value.get('ratio') as DoubleValue).getValue()).toBe(0.75);
      expect((result.value.get('message') as StringValue).getValue()).toBe('Test message');
    });
  });

  describe('Cross-Language Compatibility Verification', () => {
    test('Long type serialization matches C++ 32-bit policy', () => {
      // Test that Long values are serialized with exactly 4 bytes
      // This matches the C++ long_value policy: container_system/container/values/numeric_value.cpp
      const testValues = [0, 1, -1, 2147483647, -2147483648, 2000000000];

      for (const testValue of testValues) {
        const result = LongValue.create('test', testValue);
        expect(result.ok).toBe(true);

        if (result.ok) {
          const buffer = result.value.serialize();

          // Extract value size from wire format
          const nameLen = buffer.readUInt32LE(1);
          const valueSizeOffset = 1 + 4 + nameLen;
          const valueSize = buffer.readUInt32LE(valueSizeOffset);

          expect(valueSize).toBe(4); // Must be 4 bytes to match C++
        }
      }
    });

    test('Type IDs match C++ standard (container_system/core/value_types.h)', () => {
      // Verify our type IDs match the C++ enum value_types (lines 45-61)
      expect(ValueType.Null).toBe(0); // Reserved
      expect(ValueType.Bool).toBe(1);
      expect(ValueType.Short).toBe(2);
      expect(ValueType.UShort).toBe(3);
      expect(ValueType.Int).toBe(4);
      expect(ValueType.UInt).toBe(5);
      expect(ValueType.Long).toBe(6); // 32-bit enforced
      expect(ValueType.ULong).toBe(7); // 32-bit enforced
      expect(ValueType.LLong).toBe(8); // 64-bit
      expect(ValueType.ULLong).toBe(9); // 64-bit
      expect(ValueType.Float).toBe(10);
      expect(ValueType.Double).toBe(11);
      expect(ValueType.Bytes).toBe(12);
      expect(ValueType.String).toBe(13);
      expect(ValueType.Container).toBe(14);
      expect(ValueType.Array).toBe(15); // Node.js extension
    });

    test('Wire format byte order is little-endian', () => {
      // All implementations must use little-endian for multi-byte integers
      const result = IntValue.create('test', 0x12345678);
      expect(result.ok).toBe(true);

      if (result.ok) {
        const buffer = result.value.serialize();
        const nameLen = buffer.readUInt32LE(1);
        const valueOffset = 1 + 4 + nameLen + 4;

        // Read as little-endian
        expect(buffer.readInt32LE(valueOffset)).toBe(0x12345678);

        // Verify byte order
        expect(buffer[valueOffset]).toBe(0x78);
        expect(buffer[valueOffset + 1]).toBe(0x56);
        expect(buffer[valueOffset + 2]).toBe(0x34);
        expect(buffer[valueOffset + 3]).toBe(0x12);
      }
    });
  });
});
